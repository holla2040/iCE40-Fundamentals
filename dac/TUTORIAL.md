# DAC - Verilog Tutorial

## What This Project Does

Outputs a voltage ramp using a DAC121S101 12-bit SPI DAC. When triggered, it sweeps through 200 pre-loaded values from 0 to 4095 (0V to full scale).

## Verilog Concepts Covered

- SPI protocol (transmit)
- Memory arrays and initialization
- Multi-module hierarchical design
- Edge detection
- Active-low signals
- Asynchronous reset
- Clock division

## SPI Protocol Basics

SPI (Serial Peripheral Interface) uses 3-4 signals:

```
         FPGA                    DAC
        ┌─────┐                ┌─────┐
        │     │──── SCLK ─────▶│     │  Serial Clock
        │     │──── MOSI ─────▶│     │  Master Out, Slave In
        │     │──── CS_N ─────▶│     │  Chip Select (active low)
        └─────┘                └─────┘
```

- **CS_N**: Goes low to start transaction, high to end
- **SCLK**: Clock generated by master (FPGA)
- **MOSI**: Data from master to slave, one bit per clock

The DAC121S101 expects:
- 16-bit frame: `[PD1][PD0][D11:D0][X][X]`
- PD bits = 00 for normal operation
- Data latched on falling edge of SCLK

## Code Walkthrough: Top Module

### Edge Detection

```verilog
reg [2:0] trigger_sync;
always @(posedge clk) begin
  trigger_sync <= {trigger_sync[1:0], trigger_in};
end
wire trigger_rise = (trigger_sync[2:1] == 2'b01);
```

This detects a rising edge on the trigger input:
1. Synchronize the input (like uart_rx)
2. Compare two consecutive samples
3. `2'b01` means "was 0, now 1" = rising edge

The 3-bit shift register gives us:
- `trigger_sync[0]`: Current (possibly metastable)
- `trigger_sync[1]`: Previous (stable)
- `trigger_sync[2]`: Two cycles ago (stable)

### Active-Low Reset

```verilog
wire rst_n = reset_cnt[7];

always @(posedge clk or negedge rst_n) begin
  if (!rst_n) begin
    // Reset logic
  end
```

`rst_n` means "reset, active low" - reset is active when the signal is 0.

- `negedge rst_n` triggers on the falling edge of rst_n
- `!rst_n` is true when rst_n is low (reset active)

This is **asynchronous reset** - it happens immediately, not waiting for a clock edge.

## Code Walkthrough: dac_sweep Module

### Memory Array with File Initialization

```verilog
reg [11:0] dac_memory [0:NUM_POINTS-1];

initial begin
  $readmemh("ramp.mem", dac_memory);
end
```

- `reg [11:0] dac_memory [0:199]` declares 200 twelve-bit values
- `$readmemh` reads hexadecimal values from a file at synthesis time
- The file `ramp.mem` contains one hex value per line: `000`, `014`, `029`, etc.

### Synchronous Memory Read

```verilog
always @(posedge clk) begin
  dac_mem_rd_data <= dac_memory[point_index];
end
```

Memory reads are registered - the output appears one clock cycle after the address. That's why the state machine has a `LOAD` state that waits one cycle.

### Sweep State Machine

```
IDLE ──▶ LOAD ──▶ SEND_DAC ──▶ WAIT_DAC ──┐
  ▲                              │        │
  │                              │        │
  └──────────────────────────────┴────────┘
         (done or next point)
```

1. **IDLE**: Wait for start signal
2. **LOAD**: Wait one clock for memory read
3. **SEND_DAC**: Start SPI transmission
4. **WAIT_DAC**: Wait for SPI to complete, then loop or finish

## Code Walkthrough: dac_spi Module

### Frame Construction

```verilog
shift_reg <= {2'b00, data, 2'b00};
```

Builds the 16-bit SPI frame:
- `2'b00`: Power-down bits (normal operation)
- `data`: 12-bit DAC value
- `2'b00`: Don't care bits

### Clock Division

```verilog
parameter CLK_DIV = 2

clk_cnt <= clk_cnt + 1;
if (clk_cnt == CLK_DIV - 1) begin
  clk_cnt  <= 4'd0;
  dac_sclk <= ~dac_sclk;
```

The system clock is too fast for SPI. We divide it:
- Count from 0 to CLK_DIV-1
- Toggle SCLK each time we reach the limit
- With CLK_DIV=2 and 12 MHz system clock: SCLK = 6 MHz

### MSB-First Transmission

```verilog
if (dac_sclk) begin  // Falling edge
  dac_mosi  <= shift_reg[15];           // Output MSB
  shift_reg <= {shift_reg[14:0], 1'b0}; // Shift left
  bit_cnt   <= bit_cnt - 1;
end
```

Unlike UART (LSB first), SPI typically sends MSB first:
- Output bit 15 (most significant)
- Shift left, bringing in 0 from the right
- Next cycle outputs what was bit 14, etc.

### Chip Select Timing

```verilog
IDLE: begin
  dac_cs_n <= 1'b1;  // CS high when idle
  if (start) begin
    dac_cs_n <= 1'b0;  // CS low to start
    state <= SHIFT;
  end
end

DONE: begin
  dac_cs_n <= 1'b1;  // CS high when done
end
```

The chip select frames the transaction:
- Goes low before first clock edge
- Stays low during all 16 bits
- Goes high after last bit to latch the data

## Key Takeaways

- **SPI** is simpler than UART - no baud rate matching, just clock and data
- **MSB first** is typical for SPI (opposite of UART)
- **Memory arrays** can be initialized from files with `$readmemh`
- **Synchronous memory** has one-cycle read latency
- **Clock division** creates slower clocks from the system clock
- **Active-low signals** (ending in `_n`) are active when low
- **Asynchronous reset** responds immediately, not on clock edge
- **Edge detection** uses a shift register to compare consecutive samples
