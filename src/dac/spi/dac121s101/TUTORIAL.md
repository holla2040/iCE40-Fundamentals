# DAC - Verilog Tutorial

## What This Project Does

Outputs a voltage ramp using a DAC121S101 12-bit SPI DAC. When triggered, it sweeps through 200 pre-loaded values from 0 to 4095 (0V to full scale).

## Verilog Concepts Covered

- SPI protocol (transmit)
- Memory arrays and initialization
- Multi-module hierarchical design
- Edge detection
- Active-low signals
- Asynchronous reset
- Clock division

## SPI Protocol Basics

SPI (Serial Peripheral Interface) uses 3-4 signals:

```
         FPGA                    DAC
        ┌─────┐                ┌─────┐
        │     │──── SCLK ─────▶│     │  Serial Clock
        │     │──── MOSI ─────▶│     │  Master Out, Slave In
        │     │──── CS_N ─────▶│     │  Chip Select (active low)
        └─────┘                └─────┘
```

- **CS_N**: Goes low to start transaction, high to end
- **SCLK**: Clock generated by master (FPGA)
- **MOSI**: Data from master to slave, one bit per clock

The DAC121S101 expects:
- 16-bit frame: `[PD1][PD0][D11:D0][X][X]`
- PD bits = 00 for normal operation
- Data latched on falling edge of SCLK

## Code Walkthrough: Top Module

### Edge Detection

```verilog
reg [2:0] r_trigger_sync;
always @(posedge i_clk) begin
  r_trigger_sync <= {r_trigger_sync[1:0], i_trigger};
end
wire w_trigger_rise = (r_trigger_sync[2:1] == 2'b01);
```

This detects a rising edge on the trigger input:
1. Synchronize the input (like uart_rx)
2. Compare two consecutive samples
3. `2'b01` means "was 0, now 1" = rising edge

The 3-bit shift register gives us:
- `r_trigger_sync[0]`: Current (possibly metastable)
- `r_trigger_sync[1]`: Previous (stable)
- `r_trigger_sync[2]`: Two cycles ago (stable)

Note the naming: `r_` for the register, `w_` for the wire, `i_` for the input port.

### Synchronous Reset

```verilog
wire w_rst = !r_reset_cnt[7];

always @(posedge i_clk) begin
  if (w_rst) begin
    // Reset logic
  end
```

This project uses **synchronous reset** (preferred for iCE40 which has no dedicated reset routing):

- `w_rst` is high during the first 128 clock cycles after power-on
- Reset logic runs on the regular clock edge when `w_rst` is true
- This integrates better with FPGA timing analysis

## Code Walkthrough: dac_sweep Module

### Memory Array with File Initialization

```verilog
reg [11:0] r_dac_memory [0:NUM_POINTS-1];

initial begin
  $readmemh("ramp.mem", r_dac_memory);
end
```

- `reg [11:0] r_dac_memory [0:199]` declares 200 twelve-bit values
- `$readmemh` reads hexadecimal values from a file at synthesis time
- The file `ramp.mem` contains one hex value per line: `000`, `014`, `029`, etc.

### Synchronous Memory Read

```verilog
always @(posedge i_clk) begin
  r_dac_mem_rd_data <= r_dac_memory[r_point_index];
end
```

Memory reads are registered - the output appears one clock cycle after the address. That's why the state machine has a `LOAD` state that waits one cycle.

### Sweep State Machine

```
IDLE ──▶ LOAD ──▶ SEND_DAC ──▶ WAIT_DAC ──┐
  ▲                              │        │
  │                              │        │
  └──────────────────────────────┴────────┘
         (done or next point)
```

1. **IDLE**: Wait for start signal
2. **LOAD**: Wait one clock for memory read
3. **SEND_DAC**: Start SPI transmission
4. **WAIT_DAC**: Wait for SPI to complete, then loop or finish

## Code Walkthrough: dac_spi Module

### Frame Construction

```verilog
r_shift_reg <= {2'b00, i_data, 2'b00};
```

Builds the 16-bit SPI frame:
- `2'b00`: Power-down bits (normal operation)
- `i_data`: 12-bit DAC value
- `2'b00`: Don't care bits

### Clock Division

```verilog
parameter CLK_DIV = 2

r_clk_cnt <= r_clk_cnt + 1;
if (r_clk_cnt == CLK_DIV - 1) begin
  r_clk_cnt   <= 4'd0;
  o_dac_sclk <= ~o_dac_sclk;
```

The system clock is too fast for SPI. We divide it:
- Count from 0 to CLK_DIV-1
- Toggle SCLK each time we reach the limit
- With CLK_DIV=2 and 12 MHz system clock: SCLK = 6 MHz

### MSB-First Transmission

```verilog
if (o_dac_sclk) begin  // Falling edge
  o_dac_mosi  <= r_shift_reg[15];             // Output MSB
  r_shift_reg <= {r_shift_reg[14:0], 1'b0};   // Shift left
  r_bit_cnt   <= r_bit_cnt - 1;
end
```

Unlike UART (LSB first), SPI typically sends MSB first:
- Output bit 15 (most significant)
- Shift left, bringing in 0 from the right
- Next cycle outputs what was bit 14, etc.

### Chip Select Timing

```verilog
IDLE: begin
  o_dac_cs_n <= 1'b1;  // CS high when idle
  if (i_start) begin
    o_dac_cs_n <= 1'b0;  // CS low to start
    r_state <= SHIFT;
  end
end

DONE: begin
  o_dac_cs_n <= 1'b1;  // CS high when done
end
```

The chip select frames the transaction:
- Goes low before first clock edge
- Stays low during all 16 bits
- Goes high after last bit to latch the data

## Key Takeaways

- **SPI** is simpler than UART - no baud rate matching, just clock and data
- **MSB first** is typical for SPI (opposite of UART)
- **Memory arrays** can be initialized from files with `$readmemh`
- **Synchronous memory** has one-cycle read latency
- **Clock division** creates slower clocks from the system clock
- **Active-low signals** (ending in `_n`) are active when low
- **Asynchronous reset** responds immediately, not on clock edge
- **Edge detection** uses a shift register to compare consecutive samples
